/*
 * Copyright 2014 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.example.meetingapp;

import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;
import android.widget.ArrayAdapter;
import android.widget.Filter;
import android.widget.Filterable;

import com.example.wrappers.PlaceAutocompletePrediction;
import com.example.wrappers.PlacesAutocomplete;
import com.example.wrappers.PlacesAutocomplete.Request;
import com.example.wrappers.PlacesAutocompleteResponse;

import java.util.ArrayList;
import java.util.concurrent.ExecutionException;

/**
 * TODO: Insert description here. (generated by ung)
 */
public class PlacesAutocompleteAdapter extends ArrayAdapter<String> implements Filterable {
  private static final String TAG = 
      PlacesAutocompleteAdapter.class.getSimpleName();
  
  private static final PlacesAutocomplete mAutocompleteService
    = new PlacesAutocomplete("AIzaSyCtDiLiH1Qlb1PWogd8bgn8Ww8NK2_CQLk");
  
  private ArrayList<String> resultList;

  public PlacesAutocompleteAdapter(Context context, int textViewResourceId) {
      super(context, textViewResourceId);
  }

  @Override
  public int getCount() {
      return resultList.size();
  }

  @Override
  public String getItem(int index) {
      return resultList.get(index);
  }

  @Override
  public Filter getFilter() {
    Filter filter = new Filter() {
      @Override
      protected FilterResults performFiltering(CharSequence constraint) {
        FilterResults filterResults = new FilterResults();
        if (constraint != null) {
          // Retrieve the autocomplete results.
          GetSuggestionsTask task = new GetSuggestionsTask();
          task.execute(constraint.toString().replace(" ", "+"));
          try {
            resultList = task.get();
          } catch (ExecutionException e) {
            throw new RuntimeException(e);
          } catch (InterruptedException e) {
            throw new RuntimeException(e);
          }

          // Assign the data to the FilterResults
          filterResults.values = resultList;
          filterResults.count = resultList.size();
        }
        return filterResults;
      }

      @Override
      protected void publishResults(CharSequence constraint, FilterResults results) {
        if (results != null && results.count > 0) {
          notifyDataSetChanged();
        } else {
          notifyDataSetInvalidated();
        }
      }
    };
    return filter;
  }
  
  public class GetSuggestionsTask extends AsyncTask<String, Void, ArrayList<String>> {
    @Override
    protected ArrayList<String> doInBackground(String... params) {
      String input = params[0];
      Request request = PlacesAutocomplete.request(true)
            .input(input)
            .build();
      PlacesAutocompleteResponse response;
      try {
        response = mAutocompleteService.lookup(request);
      } catch (Exception e) {
        throw new RuntimeException(e);
      }
      
      Log.d(TAG, "response: " + response.status);
      Log.d(TAG, "predictions: " + response.predictions.size());
      if (response.predictions != null) {
        ArrayList<String> predictions = new ArrayList<String>();
        for (PlaceAutocompletePrediction prediction : response.predictions) {
          predictions.add(prediction.description);
        }
        return predictions;
      }
      return new ArrayList<String>();
    }
  }
}